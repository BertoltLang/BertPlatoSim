"""
This file contains tools to generate artificial noise time series

"""


import sys
import numpy as np
from numpy.random import normal













def redNoise(time, timescale, varscale):

    """
    INPUT:  . time[0..Ntime-1]: time points
            . timescale[0..Ncomp-1]: time scale tau of each red noise component
            . varscale[0..Ncomp-1]: variation scale of each red noise component
            
    OUTPUT: . signal[0..Ntime-1]: signal containing all red noise components
    
    EXAMPLE: from numpy import *
             from rednoise import rednoise
             time = linspace(0,100,10000)
             signal = rednoise(time, array([20.0]), array([1.0]))
             
             
    """

    Ntime = len(time)
    Ncomp = len(timescale)

    print("Simulating {0} component(s)".format(Ncomp))

    # Set the kick (= excitation) timestep to be one 100th of the
    # shortest noise time scale (i.e. kick often enough).

    kicktimestep = min(timescale) / 100.0
    print("Kicktimestep = {0}".format(kicktimestep))

    # Predefine some arrays

    signal = np.zeros(Ntime)
    noise = np.zeros(Ncomp)
    mu = np.zeros(Ncomp)
    sigma = np.sqrt(kicktimestep/timescale)*varscale

    # Warm up the first-order autoregressive process

    print("Warming up...")

    for i in range(2000):
        noise = noise * (1.0 - kicktimestep / timescale) + normal(mu, sigma)

    # Start simulating the granulation time series

    print("Simulating red noise component(s)")

    delta = 0.0
    currenttime = time[0] - kicktimestep

    for i in range(Ntime):

        # Compute the contribution of each component separately.
        # First advance the time series right *before* the time point i,

        while((currenttime + kicktimestep) < time[i]):
            noise = noise * (1.0 - kicktimestep / timescale) + normal(mu,sigma)
            currenttime = currenttime + kicktimestep

        # Then advance the time series with a small time step right *on* time[i]

        delta = time[i] - currenttime
        noise = noise * (1.0-delta/timescale) + normal(mu, np.sqrt(delta/timescale)*varscale)
        currenttime = time[i]

        # Add the different components to the signal. 

        signal[i] = np.sum(noise)


    # That's it!

    return(signal)











def rednoiseModel(freq, timescale, varscale):

    """
    PURPOSE: compute the mean power spectral density (PSD) corresponding to the red noise
             time series that is generated by redNoise().

    INPUT: freq:       frequency points of the PSD  [microHz | mHz | Hz]
           timescale:  see the function rednoise()
           varscale:   see the function rednoise()

    OUTPUT: psd:  power spectral density   [ppm^2/microHz | ppm^2/microHz | ppm^2/microHz]
    """

    psd = np.zeros_like(freq)

    for n in range(len(timescale)):
        sigma = varscale[n]
        tau = timescale[n]
        psd += sigma * sigma * tau / (1.0 + (2.0*np.pi*freq*tau)**2)
    
    return psd









def timeSeriesFromMeanPSD(freq, psd):

    """
    PURPOSE: Given the average noise profile in the power spectral density, compute the 
             corresponding noisy time series. 

    INPUT: freq: Array containing {n / N / deltat } with n in [0,..,Ntime/2],
                 where N is the number of time points, and deltat the time step.
                 Unit: [Hz | microHz | mHz]
           psd:  Power spectral density: abs(fourier)**2 / Ntime * timestep
                 Unit: [ppm^2/Hz | ppm^2/microHz | ppm^2/mHz]

    OUTPUT: time:    time points [s | Ms | KHz]
            signal:  [ppm]

    EXAMPLE: 

        >>> timeStep = 25.0e-6    # in Ms
        >>> Nfreq = 15001
        >>> freq = arange(float(Nfreq)) / (Nfreq-1) * 0.5 / timeStep
        >>> omega = 2*np.pi*freq
        >>> omegaMin  = 2. * np.pi *  20.0
        >>> omegaKnee = 2. * np.pi * 200.0
        >>> meanPSD = (omega**2 + omegaKnee**2)/(omega**2 + omegaMin**2) *  timeStep
        >>> time, signal = timeSeriesFromMeanPSD(freq, meanPSD)
        >>> nu, noisyPSD = FFTpowerdensity(signal, timeStep)
        >>> plt.loglog(nu, noisyPSD, c="b")
        >>> plt.loglog(freq, meanPSD, c="r")

    NOTE: - N points in the time domain correspond to N/2+1 points in the frequency 
            domain (not N/2), where the division is an _integer_ division (rounded down).

    """


    # Determine the number of time points. 

    Nfreq = len(freq)
    Ntime = 2*(Nfreq-1)

    # Determine the frequency resolution
    # Note: N points in the time domain corresponds to N/2+1 points in the frequency domain (not N/2).

    freqStep = freq[1] - freq[0]
    timeStep = 1./(freqStep*Ntime)

    # Generate the time points of the signal

    time = np.arange(Ntime) * timeStep

    # Generate the real and imaginary parts of the fourier transform with gaussian noise

    realPart = normal(0., 1., Nfreq)
    imagPart = normal(0., 1., Nfreq)

    # Construct the full fourier spectrum, using the proper scale factor
    
    fourier = np.sqrt(psd * Nfreq / timeStep) * (realPart + imagPart * 1j)

    # Inverse-FFT the fourier transform to generate the time series [ppm]

    signal = np.real(np.fft.irfft(fourier)) 

    # That's it!

    return time, signal










