"""
Run the PLATO Simulator from Python.

The Simulation class provides the opportunity to interactively tune the input parameters 
before the simulator is started. The parameters that are available can be inspected by 
just printing the Simulation object, i.e. print (sim), which will dump all the parameters 
and their current values on the command line.

Parameter values can be set as follows (sim is a Simulation object):

    sim["ObservingParameters/NumExposures"] = 2

Before executing the run() method on the Simulation, the directory for the 
output files generated by the PLATO simulator must be specified using

    sim.outputDir = <dirname>

The outputDir can also be specified during construction:

    sim = Simulation("Run-01", outputDir="/Users/rik/Work/PLATO/Simulations")

Usage example:

    Nsimulations = 4
    alpha = [100, 120, 140, 150]
    delta = [20, 30, 20, 30]
    
    for n in range(Nsimulations):
        sim = Simulation("Simul-{:02d}".format(n), outputDir="/Users/rik/Work/PLATO/Simulations")
		sim["CCD/CTI/Model"] = "Simple"
        sim["CCD/CTI/Simple/MeanCTE"] = 0.98
        sim["ObservingParameters/ExposureTime"] = 3.0
        sim["ObservingParameters/RApointing"] = alpha[n]
        sim["ObservingParameters/DecPointing"] = delta[n]

        sim.run()

    simFile = SimFile("/Users/rik/Work/PLATO/Simulations/Simul-01.hdf5")

Interactive usage example:

    >>> sim = Simulation("Simul01")
    >>> sim.outputDir = "/Users/rik/Work/PLATO/Simulations"
    >>> print (sim)
    YAML Configuration:
    CCD:
    	CTI:
    		Model: Simple
    		Simple:
		        MeanCTE: 0. 99999
        DigitalSaturation: 65535
        ElectronicOffset: 100
        FlatfieldPtPNoise: 0.016
        FullWellSaturation: 1000000
        Gain: 16
        ...
    >>> sim["CCD/CTI/Model"] = "Simple"
    >>> sim["CCD/Simple/MeanCTE"] = 0.98
    >>> print (sim["General/ProjectLocation"])
    /Users/rik/Git/PlatoSim3
    >>> simFile = sim.run()
    ...

"""

import yaml
import pyaml
import inspect
import subprocess
import os
import sys
import numpy as np

import simfile
from simfile import SimFile




class Simulation(object):
    
    """
    Simulation class allows running the PLATO simulator interactively from Python
    and tuning the input parameters before each run. For more help, type:

    >>> import simulation
    >>> print(simulation)
    """


    def __init__(self, runName, configurationFile=None, outputDir=None, debug=False):

        """
        Initialise class variables and read the default input files.
        """

        self.debug = debug
        self.runName = runName
        
        # flag to check if output directory has been specified before running the Simulation.
        
        self.hasTargetLocation = False
        self.targetOutputFilesLocation = None

        if outputDir != None:
            self.outputDir = outputDir

        self.setSimulatorLocation();

        if configurationFile:
            self.readConfigurationFile( configurationFile )
        else:
            self.readConfigurationFile( self.originalInputFilesLocation + "/inputfile.yaml" )






    def setSimulatorLocation(self):
        
        """
        Given the location of the simfile.py module, try to find the build/ folder where
        the simulator executable should be. Then set the default locations for the platosim 
        executable (i.e. build directory), and the original input files location.        
        """

        # Find the absolute path of the simfile.py. This will allow us to located the other
        # default project directories. Build in a test to check that the build sub-directory 
        # exists, otherwise this is probably not a correct default installation.

        path = inspect.getabsfile(simfile)
        path = os.path.dirname(path)  # strip off filename of the simfile module: simfile.py
        path = os.path.dirname(path)  # strip off python sub-directory
        if not os.path.isdir(path + "/build"):
            raise Exception("Unexpected directory structure for this PLATO Simulator distribution: no build sub-directory")
        
        self.platosimLocation = path

        # This is the location of the platosim executable

        self.platosimBuildLocation = self.platosimLocation + "/build"

        # This is the location of the original input files as distributed by the PLATO Simulator
        
        self.originalInputFilesLocation = self.platosimLocation + "/inputfiles"
        self.originalOutputFilesLocation = self.platosimLocation + "/outputfiles"






    @property
    def outputDir(self):
        """
        Return the output files location.
        """
        return self.targetOutputFilesLocation




    @outputDir.setter
    def outputDir(self, path):

        """
        Specify the absolute path for the output directory. This directory will contain
        a copy of the modified input file and the HDF5 output file for this simulation.
        
        If the output path doesn't exist, it is created.
        """

        if not os.path.exists(path):
            if self.debug:
                print("DEBUG: creating output directory {}.".format(path))
            self.createDirectory(path)
        
        self.targetOutputFilesLocation = path
        self.hasTargetLocation = True

        if self.debug:
            print("DEBUG: output dir set to {}.".format(path))







    def readConfigurationFile(self, filename):
        """
        Read the YAML input configuration file. 
        """
        self.configurationFilename = filename

        if self.debug:
            print ("Parsing YAML configuration file {}.".format(filename))
        
        with open(filename, 'r') as stream:
            try:
                self.yamlDocument = yaml.load(stream)
            except yaml.YAMLError as exc:
                print(exc)
        





    def getYamlConfiguration(self):
        """
        Return the YAML configuration as a dictionary.
        """
        return self.yamlDocument





    def __getitem__(self, key):

        """
        Returns the value of the input parameter (key).

        Param: key - a string containing the parameter name or "Group/ParameterName" combination

        Return: the value of the parameter, if only a Group is given the 
        """
        
        # Split the path into node names
        # E.g. "PSF/Gaussian/Sigma" into ["PSF", "Gaussian", "Sigma"]

        if key.find('/') == -1:
            parentNodeName, nodeName = key, None
            print ("usage: the given parameter name (key) should include the group name of the group that contains the parameter.")
            print ("       E.g in 'Camera/PlateScale', Camera is the group, PlateScale is the parameter.")
            return None
        else:
            nodeNames = key.split("/")

        # Navigate to the deepest node, starting from the document root

        node = self.yamlDocument 

        for nodeName in nodeNames:
            if nodeName in node:
                node = node[nodeName]
            else:
                print("ERROR: The group '{}' was not found in the yaml inputfile '{}'.".format(key, self.configurationFilename))
                return None
        
        # Return the value of the deepest node

        return node








    def __setitem__(self, key, item):
        
        """
        Update a specific node.

        Param: key - a string with parent node name and node name seperated by a slash
        Param: item - a string with the new node value, if not a string the value is converted using str()

        Return: True if node could be updated, False otherwise
        """
        
        # Ensure that the given item is a string

        item = str(item)

        # Split the path into node names
        # E.g. "PSF/Gaussian/Sigma" into ["PSF", "Gaussian", "Sigma"]

        if key.find('/') == -1:
            print ("usage: the given parameter name (key) should include the group name of the group that contains the parameter.")
            print ("       E.g in 'Camera/PlateScale', Camera is the group, PlatScale is the parameter.")
            return None
        else:
            nodeNames = key.split("/")

        # Check whether the parent node is in the document. If not, complain

        if nodeNames[0] not in self.yamlDocument:
             print("Error: no node with the name {0} found in input yaml file".format(nodeNames[0]))
             return False

        # If there is only 1 node in the path, we're finished after setting its value

        if len(nodeNames) == 1:
            self.yamlDocument[nodeNames[0]] = item
            return True

        # If we arrive here, there are at least 2 node in the path, check if 2nd parent node exists

        if nodeNames[1] not in self.yamlDocument[nodeNames[0]]:
             print("Error: no node with the name {0} found in input yaml file".format(nodeNames[0]+"/"+nodeNames[1]))
             return False

        # If there are only 2 nodes in the path, we're finished after setting its value

        if len(nodeNames) == 2:
            self.yamlDocument[nodeNames[0]][nodeNames[1]] = item
            return True

        # If we arrive here, there are at least 3 nodes in the path, check if 3rd parent node exists

        if nodeNames[2] not in self.yamlDocument[nodeNames[0]][nodeNames[1]]:
             print("Error: no node with the name {0} found in input yaml file".format(nodeNames[0]+"/"+nodeNames[1]+"/"+nodeNames[2]))
             return False

        # If there are only 3 nodes in the path, we're finished after setting its value

        if len(nodeNames) == 3:
            self.yamlDocument[nodeNames[0]][nodeNames[1]][nodeNames[2]] = item
            return True

        # If we arrive here, there are at least 4 nodes in the path, check if 4th parent node exists

        if nodeNames[3] not in self.yamlDocument[nodeNames[0]][nodeNames[1]][nodeNames[2]]:
             print("Error: no node with the name {0} found in input yaml file".format(nodeNames[0]+"/"+nodeNames[1]+"/"+nodeNames[2]+"/"+nodeNames[3]))
             return False

        # If there are only 34nodes in the path, we're finished after setting its value

        if len(nodeNames) == 4:
            self.yamlDocument[nodeNames[0]][nodeNames[1]][nodeNames[2]][nodeNames[3]] = item
            return True
  

        # If we arrive here, there are at least 5 nodes in the path. Issue a not-implemented error message.

        print("Error: detected 5 or more nodes in the path {0}".format(key))
        return False










    def createDirectory(self, path):
        try: 
            os.makedirs(path)
        except OSError as ose:
            print (ose)
            if not os.path.isdir(path):
                raise Exception("Couldn't create directory {}".format(path))

        return









    def writeYamlConfigurationFile(self, filename):
        """
        Write the modified configuration to output file location. This configuration will 
        be loaded by the PLATO Simulator when the run() method is executed.
        """
        if self.debug:
            print ("Writing the Yaml configuration file {}.".format(filename))
        with open(filename, 'w') as outfile:
            outfile.write( pyaml.dump(self.yamlDocument, indent=4, width=120) )








    def run(self, removeOutputFile=False):
        """
        Run the PLATO Simulator.

        When rerunning the same simulation again, remove the output file by setting the optional keyword to True.

        When PlatoSim fails for some reason and returns an error code (!= 0), an Exception is raised.
        """

        if not self.hasTargetLocation:
            raise Exception("Output location not set for this Simulation. Set the outputDir before executing the run() method.")

        inputFilename = "{}/{}.yaml".format(self.targetOutputFilesLocation, self.runName)
        outputFilename = "{}/{}.hdf5".format(self.targetOutputFilesLocation, self.runName)
        logFilename = "{}/{}.log".format(self.targetOutputFilesLocation, self.runName)

        if removeOutputFile:
            try:
                os.remove(outputFilename)
            except OSError:
                pass

        self.writeYamlConfigurationFile(inputFilename)

        # The run() method was only introduced with Python 3.5, use the older call() method when running e.g. Python 2.7

        if sys.version_info < (3, 5):   
            rc = subprocess.call([self.platosimBuildLocation + "/platosim", inputFilename, outputFilename, logFilename])
            if rc:
                raise Exception("Simulation.run(): PlatoSim returned with exit code {}.".format(rc))
        else:
            completedProcess = subprocess.run([self.platosimBuildLocation + "/platosim", inputFilename, outputFilename, logFilename], 
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            if completedProcess.returncode:
                if completedProcess.stdout:
                    print (str(completedProcess.stdout.decode("utf-8")))
                if completedProcess.stderr:
                    print (str(completedProcess.stderr.decode("utf-8")))
                raise Exception("Simulation.run(): PlatoSim returned with exit code {}.".format(completedProcess.returncode))

        simFile = SimFile(outputFilename)

        return simFile 







    def __str__(self):

        """
        Return a listing of all settings from both the CCD and the Photometry input files.
        If a parameter value has been updated for this Simulation, [updated] will be printed
        after the value.
        """
        root = self.yamlDocument
        msg = "YAML Configuration:\n"
        msg += pyaml.dump(root, indent=4)

        return msg







    def useNominalCamera(self):

        """
        PURPOSE: Change the input parameters to use the nominal camera's.

        REMARKS: The following parameters are updated:

                 CCD/NumColumns = 4510
                 CCD/NumRows = 4510
                 ObservingParameters/ExposureTime = 23
        """

        self.__setitem__("CCD/NumColumns", "4510")
        self.__setitem__("CCD/NumRows",    "4510")
        self.__setitem__("ObservingParameters/ExposureTime", "23")

        return







    def useFastCamera(self):

        """
        PURPOSE: Change the input parameters to use the fast camera's.

        REMARKS: The following parameters are updated:

                 CCD/NumColumns = 4510
                 CCD/NumRows = 2255
                 ObservingParameters/ExposureTime = 2.3
        """

        self.__setitem__("CCD/NumColumns", "4510")
        self.__setitem__("CCD/NumRows",    "2255")
        self.__setitem__("ObservingParameters/ExposureTime", "23")

        return


