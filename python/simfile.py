"""
SimFile - Usage examples

First open the HDF5 file

>>> f = SimFile("Simul01.hdf5")


To get the subfield image of the 10th exposure:

>>> im = f.getImage(10) 


Similarly, the corresponding smearing and bias maps can be obtained through:

>>> biasMap = f.getBiasMap(10)
>>> smearingMap = f.getSmearingMap(10)


To plot the subfield image of the 10th exposure:

>>> f.showImage(10, showStarPositions=True)


To get information of the stars that were detected on the subfield in at least one exposure.
The starIDs are the line number (starting with 0) of the original stellar input catalog.

>>> starIDs, RA, dec, Vmag, xFPmm, yFPmm, rowPix, colPix = f.getStarCatalog()


To get the coordinates of all stars within a magnitude range [minVmag, maxVmag] in image #10.

>>> ID, row, col, Xmm, Ymm = f.getStarCoordinates(10, minVmag=None, maxVmag=12.0)


To get an imagette around star #13561 in image #2:

>>> im = f.getImagette(13561, 10, radius = 2)


To get the time series of the yaw, pitch:

>>> yaw, pitch, roll = f.getYawPitchRoll()


To get the platform pointing coordinates (roll axis) in degrees:

>>> RA, dec = f.getPlatformPointingCoordinates()


To get the 2D flatfield at pixel level:

>>> prnu = f.getPRNU()


To get the 2D flatfield at intra-pixel level:

>>> irnu = f.getIRNU()


To inspect one of the input parameters that was used for the simulation
The group name and parameter name are exactly the same as in the YAML file.

>>> f.getInputParameter("ObservingParameters", "ExposureTime")

"""



import os
import numpy as np
import h5py
from matplotlib import pyplot as plt
import matplotlib.cm as cm


class SimFile (object):

    """
    This class provides the Python interface to an HDF5 file generated by the Plato Simulator.
    
    Usage examples:
        >>> myFile = SimFile("Simul01.hdf5")
        >>> myImage = myFile.getImage(23)
        >>> myFile.showImage(2)
    """


    def __init__(self, filename):

        """
        PURPOSE: open the HDF5 file

        INPUT: filename: string containing the full path of the HDF5 file

        OUTPUT: None.
        """

        self.filename = filename
        self.hdf5file = h5py.File(filename, "r")




    def __del__(self):

        """
        PURPOSE: destructor
        """

        pass







    def reload(self):

        """
        PURPOSE: close the file, and reload it. Useful when the file may have changed meanwhile.
        """

        self.hdf5file.close()
        self.hdf5file = h5py.File(self.filename, "r")
        return














    def getSmearingMap(self, exposureNr):

        """
        PURPOSE: extract the smearing map of the given exposure # from the HDF5 file (if present)

        INPUT: exposureNr: integer sequential number of the smearing map

        OUTPUT: smearingMap: 2D numpy array containing the smearing map
        """

        # Construct the smearing map name that was used to store the map

        smearingMapName = "smearingMap{0:06d}".format(exposureNr)

        # Check if the smearing map is in the file. If not: complain, if yes: copy the contents into a numpy array.

        if smearingMapName not in self.hdf5file["SmearingMaps"].keys():
            print("Error: SimfFile.getSmearingMap(): {0} not in hdf5 file".format(smearingMapName))
            return
        else:
            dataset = self.hdf5file["SmearingMaps"][smearingMapName]
            smearingMap = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(smearingMap)
            return smearingMap 












    def getBiasMap(self, exposureNr):

        """
        PURPOSE: extract the bias map of the given exposure # from the HDF5 file (if present)

        INPUT: exposureNr: integer sequential number of the bias map

        OUTPUT: biasMap: 2D numpy array containing the bias map
        """

        # Construct the bias map name that was used to store the map

        biasMapName = "biasMap{0:06d}".format(exposureNr)

        # Check if the bias map is in the file. If not: complain, if yes: copy the contents into a numpy array.

        if biasMapName not in self.hdf5file["BiasMaps"].keys():
            print("Error: SimfFile.getBiasMap(): {0} not in hdf5 file".format(biasMapName))
            return
        else:
            dataset = self.hdf5file["BiasMaps"][biasMapName]
            biasMap = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(biasMap)
            return biasMap 













    def getImage(self, imageNr):

        """
        PURPOSE: extract the image with seq. nr. 'imageNr' from the HDF5 file (if present)

        INPUT: imageNr: integer sequential number of the image

        OUTPUT: image: 2D numpy array containing the image [ADU]
        """

        # Construct the image name that was used to store the image

        imageName = "image{0:06d}".format(imageNr)

        # Check if the image is in the file. If not: complain, if yes: copy the contents into a numpy array.

        if imageName not in self.hdf5file["Images"].keys():
            print("Error: SimfFile.getImage(): {0} not in hdf5 file".format(imageName))
            return
        else:
            dataset = self.hdf5file["Images"][imageName]
            image = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(image)
            return image 












    def getSubPixelImage(self, exposureNr):

        """
        PURPOSE: extract the subpixel image (if present) with seq. nr. 'exposureNr' from the HDF5 file

        INPUT: exposureNr: integer sequential number of the subpixel image

        OUTPUT: subPixelImage: 2D numpy array containing the sub-pixel image [electrons]
        """

        # Construct the subpixel image name that was used to store the subpixel image

        subPixelImageName = "subPixelImage{0:06d}".format(exposureNr)

        # Check if the subpixel image is in the file. If not: complain, if yes: copy the contents into a numpy array.

        if "SubPixelImages" not in self.hdf5file:
            print("Error: SimFile.getSubPixelImage(): there is no SubPixelImages group in the HDF5 file")
        else:
            if subPixelImageName not in self.hdf5file["SubPixelImages"]:
                print("Error: SimfFile.getSubPixelImage(): {0} not in hdf5 file".format(subPixelImageName))
                return
            else:
                dataset = self.hdf5file["SubPixelImages"][subPixelImageName]
                subPixelImage = np.zeros(dataset.shape, dataset.dtype)
                dataset.read_direct(subPixelImage)
                return subPixelImage 












    def showImage(self, imageNr, showStarPositions=False, useTitle=True):

        """
        PURPOSE: make a plot of the requested image 

        INPUT: imageNr:           Integer sequential number of the image in the HDF5 file
               showStarPositions: True if the average star positions (averaged over the exposure)
                                  should be shown with a small green cross. False otherwise.
               useTitle:          True is an image title should be plotted, False otherwise

        OUTPUT: None

        EXAMPLE: 
            >>> file = SimFile("Simul01.hdf5")
            >>> file.showImage(23)
        """

        # Get the image from the HDF5 file

        image = self.getImage(imageNr)
        Nrows, Ncols = image.shape

        # Plot the image. Note that pixel coordinates start at the left bottom side of each pixel. 

        figure = plt.figure()
        axis = figure.add_subplot(111)
        imagePlot = axis.imshow(image, cmap=cm.hot, interpolation="nearest", origin='lower', extent=[0,Nrows,0,Ncols])

        # The large dynamic range of the pixel values often results in images where only
        # the brightest stars are visible. To improve the contrast, clip the color mapping.

        imagePlot.set_clim(np.percentile(image, 2), np.percentile(image, 98))

        # If required, overplot the true averaged star positions

        if showStarPositions:
            ID, row, col, Xmm, Ymm = self.getStarCoordinates(imageNr)
            axis.scatter(col, row, marker='x', c='g')        

        # Ensure that the axis limits are properly set.
        
        axis.set_xlim(0,Ncols)
        axis.set_ylim(0,Nrows)

        # If required, put the title

        if useTitle:
            fileBasename = os.path.splitext(self.filename)[0]                  # with the .hdf5
            title = fileBasename + " - image{0:06d}".format(imageNr)
            plt.title(title)

        # By default, matplotlib only shows the (x,y) coordinates of each pixel, but not the pixel value itself.
        # Change this by redefining the axis.format_coord

        Nrows, Ncols = image.shape
        def format_coord(x, y):
            col = int(x)
            row = int(y)
            if col>=0 and col<Ncols and row>=0 and row<Nrows:
                z = image[row,col]
                return "x={:.1f}, y={:.1f}, z={:.1f}".format(x, y, z)
            else:
                return "x={:.1f}, y={:.1f}".format(x, y)

        axis.format_coord = format_coord

        plt.xticks(np.arange(0, Nrows, 10))
        plt.yticks(np.arange(0, Ncols, 10))

        # Show the image

        plt.draw()
        plt.show()

        # That's it!

        return









    def getPsf(self, datasetName):

        """
        PURPOSE: extract the PSF from the HDF5 file (if present)

        INPUT:   the PSF name: "rebinnedPSFpixel", "rebinnedPSFsubPixel", or "rotatedPSF"
                 where rotatedPSF is at subpixel level.
                 
        OUTPUT:  psf: 2D numpy array containing the image
        """


        # Check if the image is in the file. If not: complain, if yes: copy the contents into a numpy array.

        if datasetName not in self.hdf5file["PSF"].keys():
            print("Error: SimfFile.getPsf(): {0} not in hdf5 file".format(datasetName))
            return
        else:
            dataset = self.hdf5file["PSF"][datasetName]
            image = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(image)
            return image 











    def showPsf(self, datasetName, useTitle=True):

        """
        PURPOSE: make a plot of the requested PSF

        INPUT: datasetName: the name of the dataset that contains the PSF in the HDF5 file
               This is set by the Simulator and is currently: 
                    rebinnedPSFpixel, rebinnedPSFsubPixel,  or  rotatedPSF
               useTitle: True is a title should be plotted, False otherwise

        OUTPUT: None

        EXAMPLE: 
            >>> file = SimFile("Simul01.hdf5")
            >>> file.showPsf("selectedPSF")
        """

        # Get the image from the HDF5 file
        # Flip (left-right) the image, then rotate it 90 degrees. This way the smearing lines
        # are vertical, and the image is oriented in such a way that overplotting the 
        # star x,y coordinates from getStarPixelCoordinates() becomes straightforward.

        image = np.rot90(np.fliplr(self.getPsf(datasetName)))
        Nrows, Ncols = image.shape

        # Plot the image. 

        figure = plt.figure()
        axis = figure.add_subplot(111)
        imagePlot = axis.imshow(image, cmap=cm.jet, interpolation="nearest", origin='lower', extent=[0,Nrows,0,Ncols])

        # The large dynamic range of the pixel values often results in images where only
        # the brightest stars are visible. To improve the contrast, clip the color mapping.

        #imagePlot.set_clim(np.percentile(image, 1), np.percentile(image, 99))

        # If required, put the title

        if useTitle:
            fileBasename = os.path.splitext(self.filename)[0]                  # with the .hdf5
            title = fileBasename + " - {}".format(datasetName)
            plt.title(title)

        # By default, matplotlib only shows the (x,y) coordinates of each pixel, but not the pixel value itself.
        # Change this by redefining the axis.format_coord

        Nrows, Ncols = image.shape
        def format_coord(x, y):
            col = int(x+0.5)
            row = int(y+0.5)
            if col>=0 and col<Ncols and row>=0 and row<Nrows:
                z = image[row,col]
                return "x={:.1f}, y={:.1f}, z={:.1f}".format(x, y, z)
            else:
                return "x={:.1f}, y={:.1f}".format(x, y)

        axis.format_coord = format_coord

        plt.xticks(np.arange(0, Nrows, 10))
        plt.yticks(np.arange(0, Ncols, 10))

        # Show the image

        plt.draw()
        plt.show()

        # That's it!

        return










    def getStarCatalog(self):

        """
        PURPOSE: retrieve a catalog of stars that were observed during the time series. Most stars 
                 are observed during every exposure, but at the edge of the subfield some stars may 
                 be observed during a few exposures only, depending on the ACS. The source of the 
                 information is the Star Input Catalog that the user specified before running the 
                 simulation.

                 The initial planar focal plane and pixel coordinates are the coordinates of the 
                 stars on the CCD before any Jitter or thermal distortions took place. Field distortion
                 is however taken into account when requested by the user in the YAML input file.

        INPUT: None

        OUTPUT: starIDs:        Sequential number of those stars in the input catalog that were detected
                                on the subfield in one or more exposures.
                RA:             Right ascension in decimal degrees 
                decl:           Declination in decimal degrees
                Vmag:           V magnitude
                xFPmm, yFPmm:   Initial planar focal plane coordinates of the stars [mm]
                rowPix, colPix: Initial pixel coordinates of the stars [pixels:float]

        EXAMPLE:

            >>> file = SimFile("Simul01.hdf5")
            >>> id, alpha, delta, Vmag = file.getStarCatalog()
            >>> plt.scatter(alpha, delta, c=Vmag, alpha=0.5)
        """

        # First some checks. Failure will lead to meaningful error messages

        if "starIDs" not in self.hdf5file["StarCatalog"].keys():
            print("Error: SimfFile.getStarCatalog(): not starIDs found in hdf5 file")
            return None, None, None, None, None, None, None, None

        elif "RA" not in self.hdf5file["StarCatalog"].keys():
            print("Error: SimfFile.getStarCatalog(): not RA values found in hdf5 file")
            return None, None, None, None, None, None, None, None

        elif "Dec" not in self.hdf5file["StarCatalog"].keys():
            print("Error: SimfFile.getStarCatalog(): no declination values found in hdf5 file")
            return None, None, None, None, None, None, None, None

        elif "Vmag" not in self.hdf5file["StarCatalog"].keys():
            print("Error: SimfFile.getStarCatalog(): no V magnitudes found in hdf5 file")
            return None, None, None, None, None, None, None, None


        # Extract the data from the HDF5 file

        dataset = self.hdf5file["StarCatalog"]["starIDs"]
        starIDs = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(starIDs)
         
        dataset = self.hdf5file["StarCatalog"]["RA"]
        RA = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(RA)
        
        dataset = self.hdf5file["StarCatalog"]["Dec"]
        declination = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(declination)

        dataset = self.hdf5file["StarCatalog"]["Vmag"]
        Vmag = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(Vmag)

        # xFPmm, yFPmm, rowPix, and colPix were all introduced with the same commit
        # So, testing if xFPmm is present in the StarCatalog group is sufficient

        if "xFPmm" in self.hdf5file["StarCatalog"].keys():
            dataset = self.hdf5file["StarCatalog"]["xFPmm"]
            xFPmm = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(xFPmm)
            
            dataset = self.hdf5file["StarCatalog"]["yFPmm"]
            yFPmm = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(yFPmm)
            
            dataset = self.hdf5file["StarCatalog"]["colPix"]
            colPix = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(colPix)
            
            dataset = self.hdf5file["StarCatalog"]["rowPix"]
            rowPix = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(rowPix)

            return starIDs, RA, declination, Vmag, xFPmm, yFPmm, rowPix, colPix

        # That's it!

        return starIDs, RA, declination, Vmag, None, None, None, None













    def getStarCoordinates(self, imageNr, minVmag = None, maxVmag = None):

        """
        PURPOSE: get the (fractional) pixel coordinates of all stars in the given image

        INPUT: imageNr: integer sequential number of the image in the HDF5 file
               minVmag: minimum V magnitiude. Only return stars fainter than minVmag.
                        Should be 'None' if no cut in minimum magnitude should be made.
               maxVmag: maximum V magnitude. Only return stars brighter than maxVmag.
                        Should be 'None' if no cut in minimum magnitude should be made.

        OUTPUT: starIDs: integer numpy array containing the star identifiers of those
                         stars visible in the current image (subfield). The star 
                         identifier equals the line number of the star in the input 
                         star catalog (counting from 0). 
                row: The pixel row coordinates of each star in the image (float).
                col: The pixel column coordinates of each star in the image (float).
                Xmm: The focal plane FP' x-coordinates of each star in the image
                Ymm: The focal plane FP' y-coordinates of each star in the image


        REMARKS: 
            - The coordinates returned are the time-averaged coordinates of the stars during the exposure.
            
            - To get the pixel with the higest flux of star #0, given its (row, col) coordinates:
              >>> im = file.getImage(0)
              >>> ID, row, col, Xmm, Ymm = file.getStarCoordinates(4, minVmag=6.0, maxVmag=9.0)  
              >>> im[int(row[0]), int(col[0])]

            - To use this function to overplot the positions of the stars on an image plotted by 
              showImage(), use plt.scatter(floor(col), floor(row)) because showImage uses 
              matplotlib.imshow() which switches rows and columns.

        EXAMPLE:

            >>> file = SimFile("Simul01.hdf5")
            >>> file.showImage(4)
            >>> ID, row, col, Xmm, Ymm = file.getStarCoordinates(4, minVmag=6.0, maxVmag=9.0)
            >>> plt.scatter(floor(col), floor(row), marker='x', c='g')

        """

        # Construct the exposure name that was used to store the image

        exposureGroupName = "Exposure{0:06d}".format(imageNr)


        # Check if the arrays are in the file. If not: complain, if yes: copy the contents into a numpy array.

        if exposureGroupName not in self.hdf5file["StarPositions"].keys():
            print("Error: SimfFile.getStarCoordinates(): {0} not in hdf5 file".format(exposureGroupName))
            return None, None, None, None, None

        
        # Extract the arrays from the HDF5 file

        dataset = self.hdf5file["StarPositions"][exposureGroupName]["starID"]
        starIDs = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(starIDs)

        dataset = self.hdf5file["StarPositions"][exposureGroupName]["rowPix"]
        row = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(row)
        
        dataset = self.hdf5file["StarPositions"][exposureGroupName]["colPix"]
        col = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(col)

        dataset = self.hdf5file["StarPositions"][exposureGroupName]["xFPmm"]
        Xmm = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(Xmm)

        dataset = self.hdf5file["StarPositions"][exposureGroupName]["yFPmm"]
        Ymm = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(Ymm)

        
        # Make sure that the star IDs are sorted

        sorted = np.argsort(starIDs)
        starIDs = starIDs[sorted]
        row = row[sorted]
        col = col[sorted]
        Xmm = Xmm[sorted]
        Ymm = Ymm[sorted]


        # If no cut in V magnitude is required, we're finished.

        if (minVmag == None) and (maxVmag == None):
            return starIDs, row, col, Xmm, Ymm

        # If a cut in magnitude is required, first get the magnitudes from the star input catalog.

        inputStarIDs, RA, decl, Vmag, xFPmm, yFPmm, rowPix, colPix = self.getStarCatalog()
        subFieldVmag = Vmag[np.in1d(inputStarIDs, starIDs)]

        # If the min or max V magnitude is set to None, use the default values

        if minVmag == None:
            minVmag = subFieldVmag.min()
        if maxVmag == None:
            maxVmag = subFieldVmag.max()

        # Make the magnitude cut

        selection = (subFieldVmag >= minVmag) & (subFieldVmag <= maxVmag)

        # That's it!
       
        return starIDs[selection], row[selection], col[selection], Xmm[selection], Ymm[selection]















    def getImagette(self, starID, imageNr, radius=2):

        """
        PURPOSE: returns a small square imagette around a specified star in a specified image.

        INPUT: starID: integer star identifier. Equals the line number of the star in the input 
                       star catalog (counting from 0). 
               imageNr: integer sequential number of the image in the HDF5 file
               radius: output imagette has size 2*radius+1 pixels in both x and y direction. [pixels]

        OUTPUT: imagette: float numpy array, rectangular imagette.
                          if pixel coordinates of the star are x and y, then imagette is extracted as
                          image[x-radius:x+radius+1, y-radius:y+radius+1]

        EXAMPLE:
            >>> file = SimFile("Simul01.hdf5")
            >>> imagette = file.getImagette(2345, 4)            
        """

        # Construct the image name that was used to store the image

        imageName = "image{0:06d}".format(imageNr)

        # Check if the image is in the file. If not: complain, if yes: copy the contents into a numpy array.

        if imageName not in self.hdf5file["Images"].keys():
            print("Error: SimfFile.getImagette(): {0} not in hdf5 file".format(imageName))
            return None
        else:
            dataset = self.hdf5file["Images"][imageName]
            image = np.zeros(dataset.shape, dataset.dtype)
            dataset.read_direct(image)
        

        # Get a list of the stars visible in the subimage and their coordinates
        # Check if our star is in this list. If not, complain.

        IDs, row, col, Xmm, Ymm = self.getStarCoordinates(imageNr)
        if starID not in IDs:
            print("Error: SimfFile.getImagette(): star {0} not in image {1}".format(starID, imageName))
            return None

        # Get the pixel coordinates of our star, and use it to construct the imagette borders

        xcoord = int(np.floor(row[IDs==starID])[0])
        ycoord = int(np.floor(col[IDs==starID])[0])
        xbegin = max(0, xcoord - radius) 
        xend   = min(xcoord + radius + 1, image.shape[1])
        ybegin = max(0, ycoord - radius)
        yend   = min(ycoord + radius + 1, image.shape[0])

        # Extract the imagette

        imagette = image[xbegin:xend, ybegin:yend]

        # That's it!

        return imagette









    def getYawPitchRoll(self):
    
        """
        PURPOSE: Get the yaw, pitch and roll angle values at the end of each exposure

        INPUT: None

        OUTPUT: yaw:  [arcsec]
                pitch: [arcsec]
                roll: [arcsec]

        NOTE: The yaw, pitch, roll values at the end of an exposure are not the same as the ones at 
              the beginning of the next exposure, because between two exposures there is the CCD readout time
              during which the ACS jitter continues.

        EXAMPLE:

            >>> file = SimFile("Simul01.hdf5")
            >>> yaw, pitch, roll = file.getYawPitchRoll()
        """

        # Extract the yaw values

        dataset = self.hdf5file["ACS"]["Yaw"]
        yaw = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(yaw)

        # Extract the pitch values

        dataset = self.hdf5file["ACS"]["Pitch"]
        pitch = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(pitch)

        # Extract the roll values

        dataset = self.hdf5file["ACS"]["Roll"]
        roll = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(roll)

        # That's it!

        return yaw, pitch, roll












    def getPlatformPointingCoordinates(self):

        """
        PURPOSE: Get the right ascension and declination values of the Platform pointing axis at the end of each exposure

        INPUT: None

        OUTPUT: rightAscension:  [degrees]
                declination: [degrees]

        NOTE: The coordinate values at the end of an exposure are not the same as the ones at 
              the beginning of the next exposure, because between two exposures there is the CCD readout time
              during which the ACS jitter continues.

        EXAMPLE:

            >>> file = SimFile("Simul01.hdf5")
            >>> RA, dec = file.getPlatformPointingCoordinates()
        """

        # Extract the right ascension values

        dataset = self.hdf5file["ACS"]["PlatformRA"]
        rightAscension = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(rightAscension)

        # Extract the pitch values

        dataset = self.hdf5file["ACS"]["PlatformDec"]
        declination = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(declination)

        # That's it

        return rightAscension, declination











    def getPRNU(self):

        """
        PURPOSE: retrieve the Pixel Response Non-Uniformity map from the HDF5 file
                 for the subfield on the CCD that was simulated. 

        INPUT: None

        OUTPUT: 2D float numpy array containing the flatfield map

        EXAMPLE:

            >>> file = SimFile("Simul01.hdf5")
            >>> PRNU = file.getPRNU()
            >>> plt.imshow(PRNU, cmap=cm.hot, interpolation="nearest")
            >>> plt.colorbar()
        """

        # Extract the flatfield map

        dataset = self.hdf5file["Flatfield"]["PRNU"]
        PRNU = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(PRNU)

        # That's it!

        return PRNU










    def getIRNU(self):

        """
        PURPOSE: retrieve the Intra-pixel Response Non-Uniformity map from the HDF5 file
                 for the subfield on the CCD that was simulated

        INPUT: None

        OUTPUT: 2D float numpy array containing the intrapixel flatfield map
 
        EXAMPLE:

            >>> file = SimFile("Simul01.hdf5")
            >>> IRNU = file.getIRNU()
            >>> plt.imshow(IRNU, cmap=cm.hot, interpolation="nearest")
            >>> plt.colorbar()

            To rebin the IRNU to the PRNU:

            >>> Nrows, Ncols = 100, 100      # size in pixels of the subfield
            >>> NsubPixels = 16              # 16^2 subpixels in 1 pixel
            >>> assert(IRNU.shape == (Nrows*NsubPixels, Ncols*NsubPixels))
            >>> PRNU = IRNU.reshape(Nrows, NsubPixels, Ncols, NsubPixels).sum(axis=3).sum(axis=1)
        """

        # Extract the subpixel flatfield map (IRNU)

        dataset = self.hdf5file["Flatfield"]["IRNU"]
        IRNU = np.zeros(dataset.shape, dataset.dtype)
        dataset.read_direct(IRNU)
        
        # That's it!

        return IRNU










    def getInputParameter(self, groupName, parameterName):

        """
        PURPOSE: Get an input parameter that was read from the Yaml input file and copied into the HDF5 file.

        INPUT: groupName: a parameter group as present in the Yaml input file (e.g. "Platform", "Camera")
               parameterName: name of the input parameter as present in the Yaml input file (e.g. "ExposureTime")

        OUTPUT: value of the input parameter

        EXAMPLE: 

            >>> file = SimFile("Simul01.hdf5")
            >>> file.getInputParameter("ObservingParameters", "ExposureTime")
            23.0
        """

        return self.hdf5file["/InputParameters/" + groupName].attrs[parameterName]






    def getPositionTimeSeries(self, starID):

        """
         PURPOSE: Given the ID of 1 particular star, extract the time series of its pixel
                  coordinates and its focal plane coordinates, for every image where the
                  star occurs.

         INPUT: starID: integer ID of a star

         OUTPUT: time:   time points of the time series [s]
                 rowPix: row coordinate (real-valued) of the average position of the star during the exposure
                 colPix: column coordinate (real-valued) of the average position of the star during the exposure 
                 xFPmm:  focal plane x-coordinate [mm] of the average position of the star during the exposure
                 yFPmm:  focal plane y-coordinate [mm] of the average position of the star during the exposure
        """

        allTimePoints = np.array(self.hdf5file["/StarPositions/Time"])

        colPix = []
        rowPix = []
        xFPmm = []
        yFPmm = []
        time = []

        for k in range(len(allTimePoints)):
            allStarIDsInImage = np.array(self.hdf5file["StarPositions/Exposure{0:06d}/starID".format(k)])
            if starID in allStarIDsInImage:
                colPixOfAllStars  = np.array(self.hdf5file["StarPositions/Exposure{0:06d}/colPix".format(k)])
                rowPixOfAllStars  = np.array(self.hdf5file["StarPositions/Exposure{0:06d}/rowPix".format(k)])
                xFPmmOfAllStars   = np.array(self.hdf5file["StarPositions/Exposure{0:06d}/xFPmm".format(k)])
                yFPmmOfAllStars   = np.array(self.hdf5file["StarPositions/Exposure{0:06d}/yFPmm".format(k)])

                starIndex = np.where(allStarIDsInImage==starID)[0]
                colPix.append(colPixOfAllStars[starIndex])
                rowPix.append(rowPixOfAllStars[starIndex])
                xFPmm.append(xFPmmOfAllStars[starIndex])
                yFPmm.append(yFPmmOfAllStars[starIndex])
                time.append(allTimePoints[k])

        return np.array(time).flatten(), np.array(rowPix).flatten(), np.array(colPix).flatten(),  \
               np.array(xFPmm).flatten(), np.array(yFPmm).flatten()


